//
// Copyright 2017 (C). Alex Robenko. All rights reserved.
//

// This code is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "Doxygen.h"

#include <iostream>
#include <fstream>
//#include <algorithm>

#include <boost/filesystem.hpp>
#include <boost/algorithm/string.hpp>

#include "common.h"
#include "output.h"
#include "DB.h"
#include "log.h"

namespace bf = boost::filesystem;
namespace ba = boost::algorithm;

namespace sbe2comms
{

namespace
{
const std::string DocDirName("doc");
} // namespace

Doxygen::Doxygen(DB& db)
  : m_db(db),
    m_name(db.getPackageName())
{
    ba::replace_all(m_name, " ", "_");
}

bool Doxygen::write()
{
    boost::system::error_code ec;
    auto dir = bf::path(m_db.getRootPath()) / DocDirName;
    bf::create_directories(dir, ec);
    if (ec) {
        log::error() << "Failed to create \"" << dir.string() <<
                "\" with error \"" << ec.message() << "\"!" << std::endl;
        return false;
    }


    return writeLayout() && writeConf() && writeNamespaces() && writeMain();
}

bool Doxygen::writeLayout()
{
    auto relPath = DocDirName + '/' + "layout.xml";
    auto filePath = bf::path(m_db.getRootPath()) / relPath;
    log::info() << "Generating " << relPath << std::endl;
    std::ofstream out(filePath.string());
    if (!out) {
        log::error() << "Failed to create " << filePath.string() << std::endl;
        return false;
    }

    out << "<doxygenlayout version=\"1.0\">\n" <<
           "  <navindex>\n"
           "    <tab type=\"mainpage\" visible=\"yes\" title=\"\"/>\n"
           "    <tab type=\"pages\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "    <tab type=\"modules\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "    <tab type=\"namespaces\" visible=\"yes\" title=\"\">\n"
           "      <tab type=\"namespacelist\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "      <tab type=\"namespacemembers\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "    </tab>\n"
           "    <tab type=\"classes\" visible=\"yes\" title=\"\">\n"
           "      <tab type=\"classlist\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "      <tab type=\"classindex\" visible=\"$ALPHABETICAL_INDEX\" title=\"\"/>\n"
           "      <tab type=\"hierarchy\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "      <tab type=\"classmembers\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "    </tab>\n"
           "    <tab type=\"files\" visible=\"yes\" title=\"\">\n"
           "      <tab type=\"filelist\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "      <tab type=\"globals\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "    </tab>\n"
           "    <tab type=\"examples\" visible=\"yes\" title=\"\" intro=\"\"/>\n"
           "  </navindex>\n\n"
           "  <!-- Layout definition for a class page -->\n"
           "  <class>\n"
           "    <includes visible=\"$SHOW_INCLUDE_FILES\"/>\n"
           "    <briefdescription visible=\"no\"/>\n"
           "    <detaileddescription title=\"\"/>\n"
           "    <inheritancegraph visible=\"$CLASS_GRAPH\"/>\n"
           "    <collaborationgraph visible=\"$COLLABORATION_GRAPH\"/>\n"
           "    <memberdecl>\n"
           "      <nestedclasses visible=\"yes\" title=\"\"/>\n"
           "      <publictypes title=\"\"/>\n"
           "      <services title=\"\"/>\n"
           "      <interfaces title=\"\"/>\n"
           "      <publicslots title=\"\"/>\n"
           "      <signals title=\"\"/>\n"
           "      <publicmethods title=\"\"/>\n"
           "      <publicstaticmethods title=\"\"/>\n"
           "      <publicattributes title=\"\"/>\n"
           "      <publicstaticattributes title=\"\"/>\n"
           "      <protectedtypes title=\"\"/>\n"
           "      <protectedslots title=\"\"/>\n"
           "      <protectedmethods title=\"\"/>\n"
           "      <protectedstaticmethods title=\"\"/>\n"
           "      <protectedattributes title=\"\"/>\n"
           "      <protectedstaticattributes title=\"\"/>\n"
           "      <packagetypes title=\"\"/>\n"
           "      <packagemethods title=\"\"/>\n"
           "      <packagestaticmethods title=\"\"/>\n"
           "      <packageattributes title=\"\"/>\n"
           "      <packagestaticattributes title=\"\"/>\n"
           "      <properties title=\"\"/>\n"
           "      <events title=\"\"/>\n"
           "      <privatetypes title=\"\"/>\n"
           "      <privateslots title=\"\"/>\n"
           "      <privatemethods title=\"\"/>\n"
           "      <privatestaticmethods title=\"\"/>\n"
           "      <privateattributes title=\"\"/>\n"
           "      <privatestaticattributes title=\"\"/>\n"
           "      <friends title=\"\"/>\n"
           "      <related title=\"\" subtitle=\"\"/>\n"
           "      <membergroups visible=\"yes\"/>\n"
           "    </memberdecl>\n"
           "    <memberdef>\n"
           "      <inlineclasses title=\"\"/>\n"
           "      <typedefs title=\"\"/>\n"
           "      <enums title=\"\"/>\n"
           "      <services title=\"\"/>\n"
           "      <interfaces title=\"\"/>\n"
           "      <constructors title=\"\"/>\n"
           "      <functions title=\"\"/>\n"
           "      <related title=\"\"/>\n"
           "      <variables title=\"\"/>\n"
           "      <properties title=\"\"/>\n"
           "      <events title=\"\"/>\n"
           "    </memberdef>\n"
           "    <allmemberslink visible=\"yes\"/>\n"
           "    <usedfiles visible=\"$SHOW_USED_FILES\"/>\n"
           "    <authorsection visible=\"yes\"/>\n"
           "  </class>\n\n"
           "  <namespace>\n"
           "    <briefdescription visible=\"yes\"/>\n"
           "    <memberdecl>\n"
           "      <nestednamespaces visible=\"yes\" title=\"\"/>\n"
           "      <constantgroups visible=\"yes\" title=\"\"/>\n"
           "      <classes visible=\"yes\" title=\"\"/>\n"
           "      <typedefs title=\"\"/>\n"
           "      <enums title=\"\"/>\n"
           "      <functions title=\"\"/>\n"
           "      <variables title=\"\"/>\n"
           "      <membergroups visible=\"yes\"/>\n"
           "    </memberdecl>\n"
           "    <detaileddescription title=\"\"/>\n"
           "    <memberdef>\n"
           "      <inlineclasses title=\"\"/>\n"
           "      <typedefs title=\"\"/>\n"
           "      <enums title=\"\"/>\n"
           "      <functions title=\"\"/>\n"
           "      <variables title=\"\"/>\n"
           "    </memberdef>\n"
           "    <authorsection visible=\"yes\"/>\n"
           "  </namespace>\n\n"
           "  <file>\n"
           "    <briefdescription visible=\"yes\"/>\n"
           "    <includes visible=\"$SHOW_INCLUDE_FILES\"/>\n"
           "    <includegraph visible=\"$INCLUDE_GRAPH\"/>\n"
           "    <includedbygraph visible=\"$INCLUDED_BY_GRAPH\"/>\n"
           "    <sourcelink visible=\"yes\"/>\n"
           "    <memberdecl>\n"
           "      <classes visible=\"yes\" title=\"\"/>\n"
           "      <namespaces visible=\"yes\" title=\"\"/>\n"
           "      <constantgroups visible=\"yes\" title=\"\"/>\n"
           "      <defines title=\"\"/>\n"
           "      <typedefs title=\"\"/>\n"
           "      <enums title=\"\"/>\n"
           "      <functions title=\"\"/>\n"
           "      <variables title=\"\"/>\n"
           "      <membergroups visible=\"yes\"/>\n"
           "    </memberdecl>\n"
           "    <detaileddescription title=\"\"/>\n"
           "    <memberdef>\n"
           "      <inlineclasses title=\"\"/>\n"
           "      <defines title=\"\"/>\n"
           "      <typedefs title=\"\"/>\n"
           "      <enums title=\"\"/>\n"
           "      <functions title=\"\"/>\n"
           "      <variables title=\"\"/>\n"
           "    </memberdef>\n"
           "    <authorsection/>\n"
           "  </file>\n\n"
           "  <group>\n"
           "    <briefdescription visible=\"yes\"/>\n"
           "    <groupgraph visible=\"$GROUP_GRAPHS\"/>\n"
           "    <memberdecl>\n"
           "      <nestedgroups visible=\"yes\" title=\"\"/>\n"
           "      <dirs visible=\"yes\" title=\"\"/>\n"
           "      <files visible=\"yes\" title=\"\"/>\n"
           "      <namespaces visible=\"yes\" title=\"\"/>\n"
           "      <classes visible=\"yes\" title=\"\"/>\n"
           "      <defines title=\"\"/>\n"
           "      <typedefs title=\"\"/>\n"
           "      <enums title=\"\"/>\n"
           "      <enumvalues title=\"\"/>\n"
           "      <functions title=\"\"/>\n"
           "      <variables title=\"\"/>\n"
           "      <signals title=\"\"/>\n"
           "      <publicslots title=\"\"/>\n"
           "      <protectedslots title=\"\"/>\n"
           "      <privateslots title=\"\"/>\n"
           "      <events title=\"\"/>\n"
           "      <properties title=\"\"/>\n"
           "      <friends title=\"\"/>\n"
           "      <membergroups visible=\"yes\"/>\n"
           "    </memberdecl>\n"
           "    <detaileddescription title=\"\"/>\n"
           "    <memberdef>\n"
           "      <pagedocs/>\n"
           "      <inlineclasses title=\"\"/>\n"
           "      <defines title=\"\"/>\n"
           "      <typedefs title=\"\"/>\n"
           "      <enums title=\"\"/>\n"
           "      <enumvalues title=\"\"/>\n"
           "      <functions title=\"\"/>\n"
           "      <variables title=\"\"/>\n"
           "      <signals title=\"\"/>\n"
           "      <publicslots title=\"\"/>\n"
           "      <protectedslots title=\"\"/>\n"
           "      <privateslots title=\"\"/>\n"
           "      <events title=\"\"/>\n"
           "      <properties title=\"\"/>\n"
           "      <friends title=\"\"/>\n"
           "    </memberdef>\n"
           "    <authorsection visible=\"yes\"/>\n"
           "  </group>\n\n"
           "  <directory>\n"
           "    <briefdescription visible=\"yes\"/>\n"
           "    <directorygraph visible=\"yes\"/>\n"
           "    <memberdecl>\n"
           "      <dirs visible=\"yes\"/>\n"
           "      <files visible=\"yes\"/>\n"
           "    </memberdecl>\n"
           "    <detaileddescription title=\"\"/>\n"
           "  </directory>\n"
           "</doxygenlayout>\n";
    return true;
}

bool Doxygen::writeConf()
{
    auto relPath = DocDirName + '/' + "doxygen.conf";
    auto filePath = bf::path(m_db.getRootPath()) / relPath;
    log::info() << "Generating " << relPath << std::endl;
    std::ofstream out(filePath.string());
    if (!out) {
        log::error() << "Failed to create " << filePath.string() << std::endl;
        return false;
    }

    auto& pkgName = m_db.getPackageName();
    auto dirName = pkgName;
    ba::replace_all(dirName, " ", "_");

    out << "DOXYFILE_ENCODING      = UTF-8\n"
           "PROJECT_NAME           = \"" << pkgName << "\"\n"
           "PROJECT_BRIEF          = \"Documentation for " << pkgName << " project.\"\n"
           "OUTPUT_DIRECTORY = /" << dirName << "\n"
           "BRIEF_MEMBER_DESC      = YES\n"
           "REPEAT_BRIEF           = YES\n"
           "ALWAYS_DETAILED_SEC    = NO\n"
           "INLINE_INHERITED_MEMB  = YES\n"
           "FULL_PATH_NAMES        = YES\n"
           "SHORT_NAMES            = NO\n"
           "INHERIT_DOCS           = YES\n"
           "SEPARATE_MEMBER_PAGES  = NO\n"
           "TAB_SIZE               = 4\n"
           "OPTIMIZE_OUTPUT_FOR_C  = NO\n"
           "OPTIMIZE_OUTPUT_JAVA   = NO\n"
           "OPTIMIZE_FOR_FORTRAN   = NO\n"
           "OPTIMIZE_OUTPUT_VHDL   = NO\n"
           "MARKDOWN_SUPPORT       = YES\n"
           "AUTOLINK_SUPPORT       = YES\n"
           "BUILTIN_STL_SUPPORT    = YES\n"
           "CPP_CLI_SUPPORT        = NO\n"
           "SIP_SUPPORT            = NO\n"
           "IDL_PROPERTY_SUPPORT   = YES\n"
           "DISTRIBUTE_GROUP_DOC   = NO\n"
           "GROUP_NESTED_COMPOUNDS = NO\n"
           "SUBGROUPING            = YES\n"
           "INLINE_GROUPED_CLASSES = NO\n"
           "INLINE_SIMPLE_STRUCTS  = NO\n"
           "TYPEDEF_HIDES_STRUCT   = NO\n"
           "LOOKUP_CACHE_SIZE      = 0\n"
           "EXTRACT_ALL            = NO\n"
           "EXTRACT_PRIVATE        = NO\n"
           "EXTRACT_PACKAGE        = NO\n"
           "EXTRACT_STATIC         = NO\n"
           "EXTRACT_LOCAL_CLASSES  = YES\n"
           "EXTRACT_LOCAL_METHODS  = NO\n"
           "EXTRACT_ANON_NSPACES   = NO\n"
           "HIDE_UNDOC_MEMBERS     = YES\n"
           "HIDE_UNDOC_CLASSES     = YES\n"
           "HIDE_FRIEND_COMPOUNDS  = NO\n"
           "HIDE_IN_BODY_DOCS      = NO\n"
           "INTERNAL_DOCS          = NO\n"
           "CASE_SENSE_NAMES       = YES\n"
           "HIDE_SCOPE_NAMES       = NO\n"
           "HIDE_COMPOUND_REFERENCE= NO\n"
           "SHOW_INCLUDE_FILES     = YES\n"
           "SHOW_GROUPED_MEMB_INC  = NO\n"
           "FORCE_LOCAL_INCLUDES   = YES\n"
           "INLINE_INFO            = NO\n"
           "SORT_MEMBER_DOCS       = YES\n"
           "SORT_BRIEF_DOCS        = NO\n"
           "SORT_MEMBERS_CTORS_1ST = YES\n"
           "SORT_GROUP_NAMES       = NO\n"
           "SORT_BY_SCOPE_NAME     = YES\n"
           "STRICT_PROTO_MATCHING  = NO\n"
           "GENERATE_TODOLIST      = YES\n"
           "GENERATE_TESTLIST      = YES\n"
           "GENERATE_BUGLIST       = YES\n"
           "GENERATE_DEPRECATEDLIST= YES\n"
           "MAX_INITIALIZER_LINES  = 30\n"
           "SHOW_USED_FILES        = YES\n"
           "SHOW_FILES             = YES\n"
           "SHOW_NAMESPACES        = YES\n"
           "LAYOUT_FILE            = doc/layout.xml\n"
           "QUIET                  = YES\n"
           "WARNINGS               = YES\n"
           "WARN_IF_UNDOCUMENTED   = NO\n"
           "WARN_IF_DOC_ERROR      = YES\n"
           "WARN_NO_PARAMDOC       = YES\n"
           "WARN_AS_ERROR          = YES\n"
           "WARN_FORMAT            = \"$file:$line: $text\"\n"
           "INPUT_ENCODING         = UTF-8\n"
           "RECURSIVE              = YES\n"
           "EXCLUDE                = cc_plugin\n"
           "EXCLUDE_SYMLINKS       = NO\n"
           "EXCLUDE_PATTERNS       = */cc_plugin/* */install/*\n"
           "EXCLUDE_SYMBOLS        = *details *cc_plugin\n"
           "EXAMPLE_RECURSIVE      = NO\n"
           "FILTER_SOURCE_FILES    = NO\n"
           "SOURCE_BROWSER         = NO\n"
           "INLINE_SOURCES         = NO\n"
           "STRIP_CODE_COMMENTS    = YES\n"
           "REFERENCED_BY_RELATION = NO\n"
           "REFERENCES_RELATION    = NO\n"
           "REFERENCES_LINK_SOURCE = YES\n"
           "SOURCE_TOOLTIPS        = YES\n"
           "USE_HTAGS              = NO\n"
           "VERBATIM_HEADERS       = YES\n"
           "CLANG_ASSISTED_PARSING = NO\n"
           "CLANG_OPTIONS          =\n"
           "ALPHABETICAL_INDEX     = YES\n"
           "COLS_IN_ALPHA_INDEX    = 5\n"
           "GENERATE_HTML          = YES\n"
           "HTML_OUTPUT            = html\n"
           "HTML_FILE_EXTENSION    = .html\n"
           "HTML_COLORSTYLE_HUE    = 220\n"
           "HTML_COLORSTYLE_SAT    = 100\n"
           "HTML_COLORSTYLE_GAMMA  = 80\n"
           "HTML_TIMESTAMP         = YES\n"
           "HTML_DYNAMIC_SECTIONS  = NO\n"
           "HTML_INDEX_NUM_ENTRIES = 100\n"
           "GENERATE_DOCSET        = NO\n"
           "GENERATE_HTMLHELP      = NO\n"
           "GENERATE_QHP           = NO\n"
           "GENERATE_ECLIPSEHELP   = NO\n"
           "DISABLE_INDEX          = NO\n"
           "GENERATE_TREEVIEW      = NO\n"
           "ENUM_VALUES_PER_LINE   = 4\n"
           "TREEVIEW_WIDTH         = 250\n"
           "EXT_LINKS_IN_WINDOW    = NO\n"
           "FORMULA_FONTSIZE       = 10\n"
           "FORMULA_TRANSPARENT    = YES\n"
           "USE_MATHJAX            = NO\n"
           "SEARCHENGINE           = NO\n"
           "SERVER_BASED_SEARCH    = NO\n"
           "EXTERNAL_SEARCH        = NO\n"
           "SEARCHDATA_FILE        = searchdata.xml\n"
           "GENERATE_LATEX         = NO\n"
           "GENERATE_RTF           = NO\n"
           "GENERATE_MAN           = NO\n"
           "GENERATE_XML           = NO\n"
           "GENERATE_DOCBOOK       = NO\n"
           "GENERATE_AUTOGEN_DEF   = NO\n"
           "GENERATE_PERLMOD       = NO\n"
           "ENABLE_PREPROCESSING   = YES\n"
           "MACRO_EXPANSION        = NO\n"
           "EXPAND_ONLY_PREDEF     = NO\n"
           "SEARCH_INCLUDES        = YES\n"
           "PREDEFINED             = FOR_DOXYGEN_DOC_ONLY\n"
           "SKIP_FUNCTION_MACROS   = YES\n"
           "ALLEXTERNALS           = NO\n"
           "EXTERNAL_GROUPS        = YES\n"
           "EXTERNAL_PAGES         = YES\n"
           "PERL_PATH              = /usr/bin/perl\n"
           "CLASS_DIAGRAMS         = YES\n"
           "HIDE_UNDOC_RELATIONS   = YES\n"
           "HAVE_DOT               = NO\n";

    return true;
}

bool Doxygen::writeNamespaces()
{
    auto& ns = m_db.getProtocolNamespace();
    auto nsFile = ns + ".dox";
    if (ns.empty()) {
        nsFile = "namespaces" + nsFile;
    }

    auto relPath = DocDirName + '/' + nsFile;
    auto filePath = bf::path(m_db.getRootPath()) / relPath;
    log::info() << "Generating " << relPath << std::endl;
    std::ofstream out(filePath.string());
    if (!out) {
        log::error() << "Failed to create " << filePath.string() << std::endl;
        return false;
    }

    if (!ns.empty()) {
        out << "/// \\namespace " << ns << "\n"
               "/// \\brief Main namespace for all classes / functions of this protocol library.\n\n";
    }

    out << "/// \\namespace " << common::scopeFor(ns, common::messageNamespaceNameStr()) << "\n"
           "/// \\brief Namespace for all the messages defined in this protocol.\n\n"
           "/// \\namespace " << common::scopeFor(ns, common::fieldNamespaceNameStr()) << "\n"
           "/// \\brief Namespace for all the stand alone fields defined in this protocol.\n\n"
           "/// \\namespace " << common::scopeFor(ns, common::builtinNamespaceNameStr()) << "\n"
           "/// \\brief Namespace for all implicitly defined (built-in) fields.\n\n";
    return true;
}

bool Doxygen::writeMain()
{
    auto relPath = DocDirName + "/main.dox";
    auto filePath = bf::path(m_db.getRootPath()) / relPath;
    log::info() << "Generating " << relPath << std::endl;
    std::ofstream out(filePath.string());
    if (!out) {
        log::error() << "Failed to create " << filePath.string() << std::endl;
        return false;
    }

    auto& ns = m_db.getProtocolNamespace();
    auto interfaceType = common::scopeFor(ns, common::msgInterfaceStr());
    auto idType = common::scopeFor(ns, common::msgIdEnumName());
    std::string endian("comms::traits::endian::Little");
    if (ba::ends_with(m_db.getEndian(), "BigEndian")) {
        ba::replace_all(endian, "Little", "Big");
    }
    auto messageNs = common::scopeFor(ns, common::messageNamespaceNameStr());
    auto fieldNs = common::scopeFor(ns, common::fieldNamespaceNameStr());
    auto builtinNs = common::scopeFor(ns, common::builtinNamespaceNameStr());
    auto allMessages = common::scopeFor(ns, common::allMessagesStr());

    std::string fieldsScopeExample;
    for (auto& m : m_db.getMessages()) {
        assert(m.second);
        if (!m.second->hasFields()) {
            continue;
        }

        fieldsScopeExample = " (for example \\ref " + common::scopeFor(ns, common::messageNamespaceStr() + m.first + common::fieldsSuffixStr()) + ")";
    }

    out << "/// \\mainpage " << m_db.getPackageName() << " Binary Protocol\n"
           "/// \\tableofcontents\n"
           "/// This library implements \"" << m_db.getPackageName() << "\" binary protocol in terms of\n"
           "/// <a href=\"\">COMMS Library</a>.\n"
           "/// It is highly recommended to have documentation of the latter also opened and used for reference\n"
           "/// in order to fully understand this tutorial.\n"
           "/// \n"
           "/// \\section main_page_interface Interface Class\n"
           "/// The main philosophy of the \\b COMMS library is to have single \n"
           "/// implementation of the messages and fields in the binary protocol, while\n"
           "/// allowing the application being developed to configure polymorphic interfaces\n"
           "/// as well as data types for some critical fields.\n"
           "///\n"
           "/// The basic interface class is defined to be \\ref " << interfaceType << ". It defines\n"
           "/// the protocol endian as well as internal message id type (\\ref " << idType << ").\n"
           "/// \\code\n"
           "/// class " << interfaceType << "\n"
           "/// {\n"
           "///     // Define endian type tag\n"
           "///     using Endian = " << endian << ";\n"
           "///\n"
           "///     // Define type of the message ID\n"
           "///     using MsdIdType = " << idType << ";\n"
           "///\n"
           "///     // Define type of the message ID when used as function parameter\n"
           "///     using MsgIdParamType = " << idType << ";\n"
           "///\n"
           "///     // Set the blockLength value (used by transport framing)\n"
           "///     void setBlockLength(std::size_t value);\n"
           "///\n"
           "///     // Get the blockLength value\n"
           "///     std::size_t getBlockLength() const;\n"
           "///\n"
           "///     // Set the version value\n"
           "///     void setVersion(unsigned value);\n"
           "///\n"
           "///     // Get the version value\n"
           "///     unsigned getVersion() const;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// This basic interface does \\b NOT define any virtual functions. However,\n"
           "/// it may be extended using various options from \\b comms::option namespace.\n"
           "/// Below is basic guide and examples on available options. For more details please\n"
           "/// read the <b>\"Messages Tutorial\"</b> page of the \\b COMMS library documentation.\n"
           "///\n"
           "/// \\subsection main_page_interface_read Polymorphic Read\n"
           "/// In order to introduce polymorphic read functionality, provide type of\n"
           "/// read iterator using \\b comms::option::ReadIterator option.\n"
           "/// \\code\n"
           "/// using MyInterface = \n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::ReadIterator<const std::uint8_t*>\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// The code is equivalent to having the following member types and functions:\n"
           "/// \\code\n"
           "/// class MyInterface\n"
           "/// {\n"
           "/// public:\n"
           "///     // Iterator used for reading\n"
           "///     using ReadIterator = const std::uint8_t*;\n"
           "///\n"
           "///     // Read operation (using NVI idiom)\n"
           "///     comms::ErrorStatus read(ReadIterator& iter, std::size_t len)\n"
           "///     {\n"
           "///         return readImpl(iter, len);\n"
           "///     }\n"
           "///\n"
           "/// protected:\n"
           "///     // Polymorphic read implemented in actual message class\n"
           "///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) = 0;\n"
           "/// };\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_interface_write Polymorphic Write\n"
           "/// In order to introduce polymorphic write functionality, provide type of\n"
           "/// write iterator using \\b comms::option::WriteIterator option.\n"
           "/// \\code\n"
           "/// using MyInterface =\n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::WriteIterator<std::uint8_t*>\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// The code is equivalent to having the following member types and functions:\n"
           "/// \\code\n"
           "/// class MyInterface\n"
           "/// {\n"
           "/// public:\n"
           "///     // Iterator used for writing\n"
           "///     using WriteIterator = std::uint8_t*;\n"
           "///\n"
           "///     // Write operation (using NVI idiom)\n"
           "///     comms::ErrorStatus write(WriteIterator& iter, std::size_t len) const\n"
           "///     {\n"
           "///         return writeImpl(iter, len);\n"
           "///     }\n"
           "///\n"
           "/// protected:\n"
           "///     // Polymorphic write implemented in actual message class\n"
           "///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len) const = 0;\n"
           "/// };\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_interface_length Polymorphic Serialisation Length Retrieval\n"
           "/// In order to introduce polymorphic serialisation length retrieval functionality, \n"
           "/// pass \\b comms::option::LengthInfoInterface option to the \\ref " << interfaceType << "\n"
           "/// interface class.\n"
           "/// \\code\n"
           "/// using MyInterface = \n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::LengthInfoInterface\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// The code is equivalent to having the following member functions:\n"
           "/// \\code\n"
           "/// class MyInterface\n"
           "/// {\n"
           "/// public:\n"
           "///     // Length retrieval operation (using NVI idiom)\n"
           "///     std::size_t length() const\n"
           "///     {\n"
           "///         return lengthImpl();\n"
           "///     }\n"
           "/// \n"
           "/// protected:\n"
           "///     // Polymorphic length retrieval implemented in actual message class\n"
           "///     virtual std::size_t lengthImpl() const = 0;\n"
           "/// };\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_interface_id Polymorphic Message ID Retrieval\n"
           "/// In order to introduce polymorphic message ID retrieval functionality,\n"
           "/// pass \\b comms::option::IdInfoInterface option to the \\ref " << interfaceType << "\n"
           "/// interface class.\n"
           "/// \\code\n"
           "/// using MyInterface =\n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::IdInfoInterface\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// The code is equivalent to having the following member functions:\n"
           "/// \\code\n"
           "/// class MyInterface\n"
           "/// {\n"
           "/// public:\n"
           "///     // ID retrieval operation (using NVI idiom)\n"
           "///     MsgIdParamType getId() const\n"
           "///     {\n"
           "///         return getIdImpl();\n"
           "///     }\n"
           "///\n"
           "/// protected:\n"
           "///     // Polymorphic id retrieval implemented in actual message class\n"
           "///     virtual MsgIdParamType getIdImpl() const = 0;\n"
           "/// };\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_interface_valid Polymorphic Validity Check\n"
           "/// The SBE schemas allow limiting range of valid values for some fields.\n"
           "/// The message is considered to be valid if all of its fields are valid.\n"
           "/// In order to introduce polymorphic message validity check functionality, \n"
           "/// pass \\b comms::option::ValidCheckInterface option to the \\ref " << interfaceType <<"\n"
           "/// interface class.\n"
           "/// \\code\n"
           "/// using MyInterface = \n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::ValidCheckInterface\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// The code is equivalent to having the following member functions:\n"
           "/// \\code\n"
           "/// class MyInterface\n"
           "/// {\n"
           "/// public:\n"
           "///     // Validity check operation (using NVI idiom)\n"
           "///     bool valid() const\n"
           "///     {\n"
           "///         return validImpl();\n"
           "///     }\n"
           "/// \n"
           "/// protected:\n"
           "///     // Polymorphic validity check implemented in actual message class\n"
           "///     virtual bool validImpl() const = 0;\n"
           "/// };\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_interface_dispatch Polymorphic Dispatch to Handling\n"
           "/// In order to introduce polymorphic dispatch of the message to its handling function,\n"
           "/// provide the type of your handling object using \\b comms::option::Handler option.\n"
           "/// Please refer to \\ref main_page_handling section for details on the required interface\n"
           "/// of the handling object type.\n"
           "/// \\code\n"
           "/// using MyInterface =\n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::Handler<MyHandler>\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// The code is equivalent to having the following type and member functions:\n"
           "/// \\code\n"
           "/// class MyInterface\n"
           "/// {\n"
           "/// public:\n"
           "///     // Redefinition of the handler type\n"
           "///     using Handler = MyHandler;\n"
           "///\n"
           "///     // Dispatch to handling operation (using NVI idiom)\n"
           "///     void dispatch(MyHandler& handler) const\n"
           "///     {\n"
           "///         dispatchImpl(handler);\n"
           "///     }\n"
           "///\n"
           "/// protected:\n"
           "///     // Polymorphic dispatch to handling implemented in actual message class\n"
           "///     virtual void dispatchImpl() const = 0;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// \\b NOTE, that \\b dispatch() member function may return a value (handling status), please\n"
           "/// refer to \\ref main_page_handling section for details.\n"
           "///\n"
           "/// \\subsection main_page_interface_refresh Polymorphic Refresh\n"
           "/// This library allows manual update of the message object contents, such as\n"
           "/// updating the version of the message. Such an update, may result the message\n"
           "/// object being in an invalid state, where some fields are marked to exist and will be\n"
           "/// serialised in write operation, when they should not be according to the new\n"
           "/// version value. The \\b COMMS library provides a @b refresh() interface member function\n"
           "/// for such cases. It can be enabled by using \\b comms::option::RefreshInterface\n"
           "/// option.\n"
           "/// \\code\n"
           "/// using MyInterface =\n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::RefreshInterface\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// The code is equivalent to having the following member functions:\n"
           "/// \\code\n"
           "/// class MyInterface\n"
           "/// {\n"
           "/// public:\n"
           "///     // Refresh operation (using NVI idiom)\n"
           "///     bool refresh()\n"
           "///     {\n"
           "///         return refreshImpl();\n"
           "///     }\n"
           "///\n"
           "/// protected:\n"
           "///     // Polymorphic refresh implemented in actual message class\n"
           "///     virtual void refreshImpl() const = 0;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// \\b NOTE, that \\b refresh() member function returns \\b true if\n"
           "/// <b>at least</b> one of the inner fields has been updated, and \\b false\n"
           "/// if message contents haven't been changed. Also note, that the message\n"
           "/// contents are updated (marked as exsiting or missing) according the\n"
           "/// version information, not the vice versa.\n"
           "///\n"
           "/// Below is an example on updating the version via common interface class:\n"
           "/// \\code\n"
           "/// bool updateVersion(MyMessage& msg, unsigned version)\n"
           "/// {\n"
           "///     msg.setVersion(version);\n"
           "///     return msg.refresh();\n"
           "/// }\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_interface_meta Meta-Programming\n"
           "/// The \\b comms::Message class (extended by \\ref " << interfaceType << ") from the \n"
           "/// \\b COMMS library defines multiple\n"
           "/// \\b constexpr static functions to allow compile time analysis of\n"
           "/// the supported interface. The \\ref " << interfaceType << " class inherits all this functions\n"
           "/// \\code\n"
           "/// namespace " << ns << "\n"
           "/// {\n"
           "///\n"
           "/// template <typename... TOpt>\n"
           "/// class Message : public\n"
           "///     comms::Message<\n"
           "///         ...,\n"
           "///         TOpt...\n"
           "///     >\n"
           "/// {\n"
           "/// public:\n"
           "///     // Check whether polymorphic read is supported\n"
           "///     static consexpr bool hasRead();\n"
           "/// \n"
           "///     // Check whether polymorphic write is supported\n"
           "///     static consexpr bool hasWrite();\n"
           "///\n"
           "///     // Check whether polymorphic length calculation is supported\n"
           "///     static consexpr bool hasLength();\n"
           "///\n"
           "///     // Check whether polymorphic message ID retrieval is supported\n"
           "///     static constexpr bool hasGetLength();\n"
           "///\n"
           "///     // Check whether polymorphic validity check is supported\n"
           "///     static constexpr bool hasValid();\n"
           "///\n"
           "///     // Check whether polymorphic dispatch is supported\n"
           "///     static constexpr bool hasDispatch();\n"
           "///\n"
           "///     // Check whether polymorphic refresh is supported\n"
           "///     static constexpr bool hasRefresh();\n"
           "/// };\n"
           "///\n"
           "/// } // namespace " << ns << "\n"
           "/// \\endcode\n"
           "/// These functions may be used at compile time to determine the supported\n"
           "/// interface if needed.\n"
           "/// \n"
           "/// \\subsection main_page_interface_input_output Input / Output Interfaces\n"
           "/// Some protocols may use uni-directional messages, i.e. some messages only\n"
           "/// sent but never received, or only received, but never sent. In this case,\n"
           "/// input messages may require polymorphic read, but do not require polymorphic\n"
           "/// write. The output messages, on the other hand, will require support for\n"
           "/// polymorphic write, but do not need support for read. If this is the case,\n"
           "/// then it is recommended to split the common interface class into two separate\n"
           "/// ones. For example:\n"
           "/// \\code\n"
           "/// // Interface for input messages\n"
           "/// using MyIntputMessage = \n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::ReadIterator<const std::uint8*>, // support for read\n"
           "///         comms::option::Handler<MyHandler> // support for dispatch\n"
           "///     >;\n"
           "///\n"
           "/// // Interface for output messages\n"
           "/// using MyOutputMessage =\n"
           "///     " << interfaceType << "<\n"
           "///         comms::option::WriteIterator<std::uint8_t*>, // support for polymorphic write\n"
           "///         comms::option::IdInfoInterface, // Support for polymorphic id retrieval\n"
           "///         comms::option::LengthInfoInterface // Support for polymorphic output buffer length calculation\n"
           "///     >;\n"
           "/// \\endcode\n"
           "/// These classes may be passed as the first template parameter to all the\n"
           "/// protocol message definition classes. See \\ref main_page_protocol_messages\n"
           "/// section below for more details.\n"
           "///\n"
           "/// \\section main_page_protocol_messages Protocol Messages\n"
           "/// All the defined protocol message classes reside in \\ref " << messageNs << " namespace\n"
           "/// (include/" << ns << "/" << common::messageNamespaceNameStr() << " folder). Every message definition class receives\n"
           "/// two template parameters. The first one is chosen common message interface\n"
           "/// class (see @ref main_page_interface section above). The second parameter is\n"
           "/// a struct of extra parameters to various fields which may be used to change\n"
           "/// the default behaviour and/or their inner data structures. Please refer to\n"
           "/// \\ref main_page_customization section below on more details.\n"
           "///\n"
           "/// Every message class extens \\b comms::MessageBase class and provides\n"
           "/// (by inheritence or overriding) the following \\b non-virtual member functions:\n"
           "/// \\code\n"
           "/// template <...>\n"
           "/// class SomeProtocolMessage : public comms::MessageBase<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     // Read from any iterator\n"
           "///     template <typename TIter>\n"
           "///     comms::ErrorStatus doRead(TIter& iter, std::size_t len);\n"
           "///\n"
           "///     // Write to any iterator\n"
           "///     template <typename TIter>\n"
           "///     comms::ErrorStatus doWrite(Iter& iter, std::size_t len) const;\n"
           "///\n"
           "///     // Get message id\n"
           "///     static constexpr MsgIdParamType doGetId();\n"
           "///\n"
           "///     // Serialisation length\n"
           "///     std::size_t doLength() const;\n"
           "///\n"
           "///     // Validity check\n"
           "///     bool doValid() const;\n"
           "///\n"
           "///     // Refresh (update fields according to version)\n"
           "///     bool doRefresh();\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// All of these member functions can be used at any time when actual message\n"
           "/// type is known, regardless of what polymorphic interface is defined.\n"
           "///\n"
           "/// For example, updating message version without need for \\ref main_page_interface_refresh\n"
           "/// \\code\n"
           "/// template <typename TMsg>\n"
           "/// void updateVersion(TMsg& msg, unsigned version)\n"
           "/// {\n"
           "///     msg.setVersion(version);\n"
           "///     msg.doRefresh();\n"
           "/// }\n"
           "/// \\endcode\n"
           "/// Based on the provided \\ref main_page_interface class (first template parameter),\n"
           "/// The \\b comms::MessageBase class (extended by actual message definition one)\n"
           "/// will automatically implement virtual \\b *Impl() member functions defined\n"
           "/// by the interface class.\n"
           "/// \\code\n"
           "/// template <...>\n"
           "/// class SomeProtocolMessage : public comms::MessageBase<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     // Read from any iterator\n"
           "///     template <typename TIter>\n"
           "///     comms::ErrorStatus doRead(TIter& iter, std::size_t len);\n"
           "///\n"
           "/// protected:\n"
           "///     // Overriding polymorphic read\n"
           "///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len)\n"
           "///     {\n"
           "///         return doRead(iter, len);\n"
           "///     }\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Every message bundles its inner fields into \\b std::tuple and provides\n"
           "/// and access to it using \\b fields() member functions (inherited from\n"
           "/// \\b comms::MessageBase).\n"
           "/// \\code\n"
           "/// template <...>\n"
           "/// class SomeProtocolMessage : public comms::MessageBase<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     // All fields bundled in std::tuple\n"
           "///     using AllFields = std::tuple<...>;\n"
           "///\n"
           "///     // Access to fields\n"
           "///     AllFields& fields();\n"
           "///\n"
           "///     // Const access to fields\n"
           "///     const AllFields& fields() const;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Empty messages, that don't define any inner field, will have an empty tuple.\n"
           "///\n"
           "/// Every non-empty message class also uses \\b COMMS_MSG_FIELDS_ACCESS() macro \n"
           "/// from \\b COMMS library with names of the fields.\n"
           "///\n"
           "/// For example:\n"
           "/// \\code\n"
           "/// class SomeProtocolMessage : public comms::MessageBase<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     COMMS_MSG_FIELDS_ACCESS(name1, name2, name3);\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// The usage of the macro defines the following convenience access enum and\n"
           "/// functions:\n"
           "/// \\code\n"
           "/// template <...>\n"
           "/// class SomeProtocolMessage : public comms::MessageBase<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     // Indices of the fields\n"
           "///     enum FieldIdx\n"
           "///     {\n"
           "///         FieldIdx_name1,\n"
           "///         FieldIdx_name2,\n"
           "///         FieldIdx_name3,\n"
           "///         FieldIdx_numOfValues\n"
           "///     };\n"
           "///\n"
           "///     // Access to first field\n"
           "///     typename std::tuple_element<FieldIdx_name1, AllFields>::type& field_name1();\n"
           "///\n"
           "///     // Const access to first field\n"
           "///     const typename std::tuple_element<FieldIdx_name1, AllFields>::type& field_name1() const;\n"
           "///\n"
           "///     // Access to second field\n"
           "///     typename std::tuple_element<FieldIdx_name2, AllFields>::type& field_name2();\n"
           "///\n"
           "///     // Const access to second field\n"
           "///     const typename std::tuple_element<FieldIdx_name2, AllFields>::type& field_name2() const;\n"
           "///\n"
           "///     // Access to third field\n"
           "///     typename std::tuple_element<FieldIdx_name3, AllFields>::type& field_name3();\n"
           "///\n"
           "///     // Const access to third field\n"
           "///     const typename std::tuple_element<FieldIdx_name3, AllFields>::type& field_name3() const;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Access to the inner fields can be using names\n"
           "/// \\code\n"
           "/// SomeProtocolMessage<...> msg;\n"
           "/// msg.field_name1().value() = ...;\n"
           "/// msg.field_name2().value() = ...;\n"
           "/// msg.field_name3().value() = ...;\n"
           "/// \\endcode\n"
           "/// or field index (can be useful in meta-programming)\n"
           "/// \\code\n"
           "/// using Msg = SomeProtocolMessage<...>;\n"
           "/// Msg msg;\n"
           "/// std::get<Msg::FieldIdx_name1>(msg.fields()).value() = ...;\n"
           "/// std::get<Msg::FieldIdx_name2>(msg.fields()).value() = ...;\n"
           "/// std::get<Msg::FieldIdx_name3>(msg.fields()).value() = ...;\n"
           "/// \\endcode\n"
           "/// \\b NOTE, that access to message fields, gives an access to a <b>field\n"
           "/// abstruction</b> object, not the value of the field. To get the value, call\n"
           "/// to \\b value() member function needs to be performed. Please refer to\n"
           "/// \\ref main_page_fields section below for more details on field classes and\n"
           "/// their interfaces.\n"
           "/// \\section main_page_handling Handling the Message\n"
           "/// The \\ref main_page_interface_dispatch section above described a way\n"
           "/// on how to allow polymorphic dispatch of the message to appropriate handling\n"
           "/// object. The class of the handling object is passed as a template\n"
           "/// parameter to \\b comms::option::Handler option. This class is expected to define\n"
           "/// \\b handle() member function for every function it is expected to handle.\n"
           "///\n"
           "/// As an example, let's assume the protocol library defines \\b Msg1, \\b Msg2,\n"
           "/// \\b Msg3, ... message classes.\n"
           "/// \\code\n"
           "/// // Common interface class for all the messages\n"
           "/// using MyInterface = " << interfaceType << "<...>;\n"
           "///\n"
           "/// class MyHandler\n"
           "/// {\n"
           "/// public:\n"
           "///     void handle(Msg1& msg);\n"
           "///     void handle(Msg2& msg);\n"
           "///     void handle(Msg3& msg);\n"
           "///\n"
           "///     // Default handling function\n"
           "///     void handle(MyInterface& msg);\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Note the existence of <b>handle(MyInterface& msg)</b> member function. It\n"
           "/// is required if not all messages are covered in other handling functions. If\n"
           "/// the exact match to message type is missing, the compiler will generate code\n"
           "/// for invocation of this default handling function.\n"
           "///\n"
           "/// The handling itself can be polymorphic:\n"
           "/// \\code\n"
           "/// class MyHandler\n"
           "/// {\n"
           "/// public:\n"
           "///     virtual void handle(Msg1& msg) = 0;\n"
           "///     virtual void handle(Msg2& msg) = 0;\n"
           "///     virtual void handle(Msg3& msg) = 0;\n"
           "///     virtual void handle(MyInterface& msg) = 0;\n"
           "/// };\n"
           "///\n"
           "/// class Handler1 : public MyHandler\n"
           "/// {\n"
           "/// public:\n"
           "///     virtual void handle(Msg1& msg) override;\n"
           "///     virtual void handle(Msg2& msg) override;\n"
           "///     ...\n"
           "/// };\n"
           "///\n"
           "/// class Handler2 : public MyHandler\n"
           "/// {\n"
           "/// public:\n"
           "///     virtual void handle(Msg1& msg) override;\n"
           "///     virtual void handle(Msg2& msg) override;\n"
           "///     ...\n"
           "/// };\n"
           "///\n"
           "/// Handler1 handler1;\n"
           "/// Handler2 handler2;\n"
           "/// std::unique_ptr<MyInterface> msg(new Msg1); // allocated message object\n"
           "/// msg->dispatch(handler1); // Dispatches to handler1\n"
           "/// msg->dispatch(handler2); // Dispatches to handler2\n"
           "/// \\endcode\n"
           "/// The handling functions may return a value. In order to support a return\n"
           "/// of the same value from the \\b dispatch() member functions of the\n"
           "/// message object (see \\ref main_page_interface_dispatch), the handler class\n"
           "/// is expected define \\b RetType inner type, which defines a type returned\n"
           "/// by all the \\b handle() member functions:\n"
           "/// \\code\n"
           "/// class MyHandler:\n"
           "/// {\n"
           "/// public:\n"
           "///     // Return type of the handling functions\n"
           "///     using RetType = bool;\n"
           "///\n"
           "///     // Handling functions\n"
           "///     RetType handle(Msg1& msg);\n"
           "///     RetType handle(Msg2& msg);\n"
           "///     ...\n"
           "///     RetType handle(MyInterface& msg);\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// In this case the \\b " << interfaceType << "::dispatch() member function will return\n"
           "/// a value of the same type:\n"
           "/// \\code\n"
           "/// bool result = msg->dispatch(handler);\n"
           "/// \\endcode\n"
           "/// The \\b COMMS library provides a helper \\b comms::GenericHandler class,\n"
           "/// which can be used for easier defined of the custom handler one. The\n"
           "/// \\b comms::GenericHandler receives 3 template parameters. The first one\n"
           "/// is common interface class for all the messages, second is all the message\n"
           "/// types to handle bundled in \\b std::tuple, and the third is optional one\n"
           "/// to specify a return type of the handling functions (defaults to \\b void).\n"
           "/// The \\b comms::GenericHandler class automatically generates \\b virtual\n"
           "/// handling function for every message type in the tuple as well as a defult\n"
           "/// one for the interface class. The body of every handling function upcasts\n"
           "/// the message type to the common interface one and invokes the \"default\"\n"
           "/// handling function, which does nothing. The custom handling class can extend\n"
           "/// the \\b comms::GenericHandler and override the provides behaviour:\n"
           "/// \\code\n"
           "/// class MyHandler : public comms::GenericHandler<MyInterface, " << allMessages << "<MyInterface> >\n"
           "/// {\n"
           "/// public:\n"
           "///     virtual void handle(Msg1& msg) override\n"
           "///     {\n"
           "///         std::cout << \"Msg1 is received\" << std::endl;\n"
           "///     }\n"
           "///\n"
           "///     virtual void handle(MyInterface& msg) override\n"
           "///     {\n"
           "///         std::cout << \"Unexpected message: \" << msg.getId() << std::endl;\n"
           "///     }\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Note, that the messages in the provided tuple must be sorted according to\n"
           "/// their numeric IDs. This library defines \\ref " << allMessages << " type which bundles\n"
           "/// all the messages of the protocol. Please use it for reference.\n"
           "///\n"
           "/// For more details, it is highly recommended to read <b>Handling Messages Tutorial</b>\n"
           "/// page of the \\b COMMS library documentation.\n"
           "///\n"
           "/// \\section main_page_fields Fields\n"
           "/// This tutorial uses term @b field for every element residing in \\b \\<types\\>\n"
           "/// and \\b \\<message\\> XML element of the \\b SBE schema. In other words every\n"
           "/// \\b \\<type\\>, \\b \\<composite\\>, \\b \\<enum\\>, \\b \\<set\\>, \\b \\<field\\>, \\b \\<group\\>, and \\b \\<data\\>\n"
           "/// is a \\b field.\n"
           "///\n"
           "/// All the fields (types) defined under common \\<types\\> XML tag implemented\n"
           "/// in separate header file and reside in \\ref " << fieldNs << " namespace.\n"
           "/// Every field defined under \\<message\\> XML tag is defined in the same\n"
           "/// file with its message class definition inside the structure starting with\n"
           "/// the message class name, but having the \\b *Fields suffix" << fieldsScopeExample << ".\n"
           "///\n"
           "/// Every such field is implemented by aliasing or extending appropriate\n"
           "/// classes from \\b comms::field namespace (provided by the \\b COMMS library).\n"
           "/// It is recommended to read the <b>Fields Tutorial</b> page from the \\b COMMS\n"
           "/// library documentation for better understanding.\n"
           "///\n"
           "/// Every field class is an abstraction around a storage value. Every such\n"
           "/// field defines similar interface, which makes template meta-programming\n"
           "/// to be relatively easy task.\n"
           "/// \\code\n"
           "/// class SomeField\n"
           "/// {\n"
           "/// public:\n"
           "///     // Value storage type\n"
           "///     using ValueType = ...;\n"
           "///\n"
           "///     // Access to stored value\n"
           "///     ValueType& value();\n"
           "///     const ValueType& value() const;\n"
           "///\n"
           "///     // Read with any iterator\n"
           "///     template <typename TIter>\n"
           "///     comms::ErrorStatus read(TIter& iter, std::size_t len);\n"
           "///\n"
           "///     // Write with any iterator\n"
           "///     template <typename TIter>\n"
           "///     comms::ErrorStatus write(TIter& iter, std::size_t len);\n"
           "///\n"
           "///     // Serialisation length retrieval\n"
           "///     std::size_t length() const\n"
           "///\n"
           "///     // Minimal serialisation length\n"
           "///     static constexpr std::size_t minLength();\n"
           "///\n"
           "///     // Maximal serialisation length\n"
           "///     static constexpr std::size_t maxLength();\n"
           "///\n"
           "///     // Value validity check\n"
           "///     vool valid() const;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Every optional field (with \\b presence=\"optional\" attribute in SBE schema)\n"
           "/// also adds the following extra functions:\n"
           "/// \\code\n"
           "/// class SomeOptionalField\n"
           "/// {\n"
           "/// public:\n"
           "///     // Check if value is null\n"
           "///     bool isNull() const;\n"
           "///\n"
           "///     // Set value to null\n"
           "///     void setNull();\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Let's cover all the available fields one by one...\n"
           "///\n"
           "/// \\subsection main_page_fields_type \\<type\\>\n"
           "/// The \\b \\<type\\> elements can be integral values, floating point values,\n"
           "/// fixed length strings, and fixed length lists.\n"
           "///\n"
           "/// \\subsubsection main_page_fields_type_int Integral Value Fields\n"
           "/// Usually look like this\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"uint16\" />\n"
           "/// \\endcode\n"
           "/// Such fields are implemented by extending the \\b comms::field::IntValue\n"
           "/// class from \\b COMMS library.\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someName : public\n"
           "///     comms::field::IntValue<\n"
           "///         FieldBase,\n"
           "///         std::uint16_t,\n"
           "///         TOpt...,\n"
           "///         comms::option::ValidNumValueRange<0, 65534L>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Note, that \\b primitiveType attribute value is mapped one-to-one with the\n"
           "/// value storage type passed to \\b comms::field::IntValue\n"
           "/// | pritimiteType | Value Storage Type |\n"
           "/// |:-------------:|:------------------:|\n"
           "/// | char          | char               |\n"
           "/// | int8          | std::int8_t        |\n"
           "/// | uint8         | std::uint8_t       |\n"
           "/// | int16         | std::int16_t       |\n"
           "/// | uint16        | std::uint16_t      |\n"
           "/// | int32         | std::int32_t       |\n"
           "/// | uint32        | std::uint32_t      |\n"
           "/// | int64         | std::int64_t       |\n"
           "/// | uint64        | std::uint64_t      |\n"
           "///\n"
           "/// Integral values may have a valid range of values specified\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"int16\" minValue=\"-500\" maxValue=\"1000\" />\n"
           "/// \\endcode\n"
           "/// Such fields use \\b comms::option::ValidNumValueRange option to limit the\n"
           "/// range of valid values. As the result, a call to \\b valid() member function\n"
           "/// of the field will check that the value in the specified range\n"
           "/// class from \\b COMMS library.\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someName : public\n"
           "///     comms::field::IntValue<\n"
           "///         FieldBase,\n"
           "///         std::int16_t,\n"
           "///         TOpt...,\n"
           "///         comms::option::ValidNumValueRange<-500, 1000>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// When such integral value field is constructed, the inner value is initialized\n"
           "/// to \\b 0. However, if the valid values range does not include \\b 0, then\n"
           "/// the inner value will be initialised to a closest to \\b 0, but still valid\n"
           "/// one. For example\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"uint16\" minValue=\"1000\" maxValue=\"2000\" />\n"
           "/// \\endcode\n"
           "/// will produce the following code\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someName : public\n"
           "///     comms::field::IntValue<\n"
           "///         FieldBase,\n"
           "///         std::uint16_t,\n"
           "///         TOpt...,\n"
           "///         comms::option::ValidNumValueRange<1000, 2000>,\n"
           "///         comms::option::DefaultNumValue<1000> // Sets the default value on construction\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Optional fields are initialised to their \\b nullValue.\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"uint16\" presence=\"optional\" />\n"
           "/// \\endcode\n"
           "/// The field definition will be\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someName : public\n"
           "///     comms::field::IntValue<\n"
           "///         ...\n"
           "///         comms::option::DefaultNumValue<65535L>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsubsection main_page_fields_type_float Floating Point Value Fields\n"
           "/// Usually look like this\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"float\" />\n"
           "/// \\endcode\n"
           "/// Such fields are implemented by extending the \\b comms::field::FloatValue\n"
           "/// \\code\n"
           "/// class from \\b COMMS library\n"
           "/// template <typename... TOpt>\n"
           "/// class someName : public\n"
           "///     comms::field::FloatValue<\n"
           "///         FieldBase,\n"
           "///         float,\n"
           "///         TOpt...\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// The values of all optional floating point fields are initialised to \\b NaN.\n"
           "/// For example the field\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"float\" present=\"optional\"/>\n"
           "/// \\endcode\n"
           "/// will have the following code executed correctly:\n"
           "/// \\code\n"
           "/// " << fieldNs << "::someName<> field;\n"
           "/// assert(field.isNull());\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsubsection main_page_fields_type_string Fixed Length String Fields\n"
           "/// All the types with \\b primitiveType=\"char\" and \\b length attribute\n"
           "/// greater than \\b are considered to be fixed length strings.\n"
           "/// For example:\n"
           "/// \\code\n"
           "/// <type name=\"Str\" primitiveType=\"char\" length=\"4\" />\n"
           "/// \\endcode\n"
           "/// Such fields are implemented by extending the \\b comms::field::String\n"
           "/// class from the \\b COMMS library.\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class Str : public\n"
           "///     comms::field::String<\n"
           "///         FieldBase,\n"
           "///         comms::option::SequenceFixedSize<4>,\n"
           "///         TOpt...\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// \\b NOTE, that by default inner value storage type of \\b comms::field::String\n"
           "/// class is \\b std::string.\n"
           "/// \\code\n"
           "/// " << fieldNs << "::Str<> field;\n"
           "/// std::string& fieldValue = field.value();\n"
           "/// \\endcode\n"
           "/// This can be changed by passing some extra options\n"
           "/// from \\b comms::option namespace to the field class definition. Please\n"
           "/// refer to \\ref main_page_customization section below for more details.\n"
           "///\n"
           "/// Also \\b note, that usage of \\b comms::option::SequenceFixedSize option\n"
           "/// above, just guarantees that field will be serialised specified number of bytes.\n"
           "/// If the size of the inner value is less than expected, the \\b write() function\n"
           "/// will write necessary amount of zeros after the value has been written. If\n"
           "/// size of the string exceeds the necessary amount, it will be truncated.\n"
           "/// The inner string value is not resized upon construction:\n"
           "/// \\code\n"
           "/// " << fieldNs << "::Str<> field;\n"
           "/// std::string& fieldValue = field.value();\n"
           "/// assert(fieldValue.empty());\n"
           "/// \\endcode\n"
           "/// If field has \\b primitiveType=\"int8\" or \\b primitiveType=\"uint8\"\n"
           "/// attribute, but also defining non-empty \\b characterEncoding attribute, then\n"
           "/// such field is also implemented by extending \\b comms::field::String.\n"
           "///\n"
           "/// \\subsubsection main_page_fields_type_list Fixed Length List Fields\n"
           "/// The \\ref main_page_fields_type_int and \\ref main_page_fields_type_float\n"
           "/// in the SBE schema may also define \\b length attribute with value greater\n"
           "/// than \\b 1. In such case the field is defined using two different classes.\n"
           "/// The first one is definition of the list element, which appends \\b *" << common::elementSuffixStr() << "\n"
           "/// suffix to its name. The second class is a definition of the list itself\n"
           "/// by extending \\b comms::field::ArrayList. For example\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"uint16\" length=\"4\" />\n"
           "/// \\endcode\n"
           "/// The generated code will look like this:\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someNameElement : public\n"
           "///     comms::field::IntValue<\n"
           "///         FieldBase,\n"
           "///         std::uint16_t,\n"
           "///         TOpt...,\n"
           "///         comms::option::ValidNumValueRange<0, 65534L>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "///\n"
           "/// template <typename... TOpt>\n"
           "/// class someName : public\n"
           "///     comms::field::ArrayList<\n"
           "///         FieldBase,\n"
           "///         someNameElement<>,\n"
           "///         TOpt...,\n"
           "///         comms::option::SequenceFixedSize<4>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// \\b NOTE, that by default inner value storage type of \\b comms::field::ArrayList\n"
           "/// class is \\b std::vector.\n"
           "/// \\code\n"
           "/// " << fieldNs << "::someName<> field;\n"
           "/// std::vector<someNameElement<> >& fieldValue = field.value();\n"
           "/// \\endcode\n"
           "/// This can be changed by passing some extra options from \\b comms::option\n"
           "/// namespace to the field class definition. Please refer to\n"
           "/// \\ref main_page_customization section below for more details.\n"
           "///\n"
           "/// Also \\b note, that inner storage value of the \\b comms::field::ArrayList\n"
           "/// is a vector of <b>other fields</b>. Let's assume the vector is populated with\n"
           "/// values, so access to the first value will look like this:\n"
           "/// \\code\n"
           "/// void processField(const " << fieldNs << "::someName<>& field)\n"
           "/// {\n"
           "///     auto& fieldValue = field.value(); // Access to the vector of element fields\n"
           "///     auto& firstElement = innerVector[0]; // The first element is a someNameElement<>\n"
           "///     std::uint16_t firstElementValue = firstElement.value(); // Access the actual value\n"
           "/// }\n"
           "/// \\endcode\n"
           "/// One more thing to \\b note, is that effect of \\b comms::option::SequenceFixedSize\n"
           "/// option is similar to one described in \\ref main_page_fields_type_string avove.\n"
           "/// It just insures appropriate number of elements to be written when field is\n"
           "/// serialised. It does \\b NOT resize the vector to appropriate length upon field\n"
           "/// construction.\n"
           "/// \\code\n"
           "/// " << fieldNs << "::someName<> field;\n"
           "/// assert(field.value().empty());\n"
           "/// \\endcode\n"
           "/// All the stated above is true for the list fields when serialisation length\n"
           "/// of single element is <b>at least</b> two bytes. If \\b primitiveType\n"
           "/// is specified to be \\b int8 or \\b uint8. It is considered to be a list\n"
           "/// of raw data when serialisation endian does not matter. In this case the\n"
           "/// there is no class that defines \\b element of the list.\n"
           "/// \\code\n"
           "/// <type name=\"someName\" primitiveType=\"uint8\" length=\"4\" />\n"
           "/// \\endcode\n"
           "/// In such case the generated code will look like this:\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someName : public\n"
           "///     comms::field::ArrayList<\n"
           "///         FieldBase,\n"
           "///         std::uint8_t,\n"
           "///         TOpt...,\n"
           "///         comms::option::SequenceFixedSize<4>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// The access to the first element of such list can look like this:\n"
           "/// \\code\n"
           "/// void processField(const " << fieldNs << "::someName<>& field)\n"
           "/// {\n"
           "///     std::vector<std::uint8_t>& fieldValue = field.value();\n"
           "///     std::uint8_t firstValue = fieldValue[0];\n"
           "/// }\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_fields_enum \\<enum\\>\n"
           "/// The enum fields are implemented by extending the \\b comms::field::EnumValue\n"
           "/// from the \\b COMMS library.\n"
           "///\n"
           "/// Let's define the following enum as an example:\n"
           "/// \\code\n"
           "/// <enum name=\"SomeEnum\" encodingType=\"uint8\">\n"
           "///     <validValue name=\"Val1\">0</validValue>\n"
           "///     <validValue name=\"Val2\">1</validValue>\n"
           "/// </enum>\n"
           "/// \\endcode\n"
           "/// First, the generated code defines enum class with underlying type\n"
           "/// matching the specified \\b encodingType. The name of the enum class\n"
           "/// is the same as the field name, but with \\b *Val suffix.\n"
           "/// \\code\n"
           "/// enum class SomeEnumVal : std::uint8_t\n"
           "/// {\n"
           "///     Val1 = static_cast<std::uint8_t>(0),\n"
           "///     Val2 = static_cast<std::uint8_t>(1)\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Then after the enum definition comes the actual field definition class\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class SomeEnum : public\n"
           "///     comms::field::EnumValue<\n"
           "///         FieldBase,\n"
           "///         SomeEnumVal,\n"
           "///         TOpt...,\n"
           "///         comms::option::ValidNumValueRange<0, 1>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Accessing the inner value may look like this:\n"
           "/// \\code\n"
           "/// " << fieldNs << "::SomeEnum<> field;\n"
           "/// SomeEnumVal& fieldValue = field.value();\n"
           "/// fieldValue = " << fieldNs << "::SomeEnumVal::Val2;\n"
           "/// \\endcode\n"
           "/// Just like with \\ref main_page_fields_type_int, the inner value is initialised\n"
           "/// to \\b 0 upon construction. However, if \\b 0 is not a valid 0, the field\n"
           "/// is automatically initialised to the closest to \\0 one. For example:\n"
           "/// \\code\n"
           "/// <enum name=\"SomeOtherEnum\" encodingType=\"int32\">\n"
           "///     <validValue name=\"Val1\">78900</validValue>\n"
           "///     <validValue name=\"Val2\">900000</validValue>\n"
           "/// </enum>\n"
           "/// \\endcode\n"
           "/// Such field definition will looke like this:\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class SomeOtherEnum : public\n"
           "///     comms::field::EnumValue<\n"
           "///         FieldBase,\n"
           "///         SomeOtherEnumVal,\n"
           "///         TOpt...,\n"
           "///         comms::option::DefaultNumValue<78900L>,\n"
           "///         comms::option::ValidNumValue<78900L>,\n"
           "///         comms::option::ValidNumValue<900000L>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "///\n"
           "/// \\subsection main_page_fields_set \\<set\\>\n"
           "/// The \\b set fields are implemented by extending the \\b comms::field::BitmaskValue\n"
           "/// from the \\b COMMS library.\n"
           "///\n"
           "/// Let's define the following set as an example:\n"
           "/// \\code\n"
           "/// <set name=\"someSet\" encodingType=\"uint8\">\n"
           "///     <choice name=\"bit0\">0</choice>\n"
           "///     <choice name=\"bit1\">1</choice>\n"
           "///     <choice name=\"bit5\">5</choice>\n"
           "///     <choice name=\"bit7\">7</choice>\n"
           "/// </set>\n"
           "/// \\endcode\n"
           "/// The generated code looks like this.\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someSet : public\n"
           "///     comms::field::BitmaskValue<\n"
           "///         FieldBase,\n"
           "///         TOpt...,\n"
           "///         comms::option::FixedLength<1>,\n"
           "///         comms::option::BitmaskReservedBits<0x5c>\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// The \\b encodingType attribute of the field definition is analysed by the\n"
           "/// \\b sbe2comms compiler to specify the serialisation length of the field\n"
           "/// using \\b comms::option::FixedLength. The \\b COMMS library in turn, analyses\n"
           "/// requested serialisation length and uses appropriate \\b unsigned type for\n"
           "/// storage (\\b std::uint8_t in this case). The list of provided choices is\n"
           "/// analysed and usage of \\b comms::option::BitmaskReservedBits option is\n"
           "/// generated to specify the unused (reserved) bits. If any of these bits is set,\n"
           "/// the call to \\b valid() member function of the field will return \\b false.\n"
           "///\n"
           "/// A call to \\b value() member function will give an access to the value storage\n"
           "/// which can be updated directly.\n"
           "/// \\code\n"
           "/// " << fieldNs << "::someSet<> field;\n"
           "/// field.value() = 0x8001; // set bit7 and bit0\n"
           "/// \\endcode\n"
           "/// The \\b comms::field::BitmaskValue class from the \\b COMMS library defines\n"
           "/// following additional convenience API functions to set/get a single bit value.\n"
           "/// \\code\n"
           "/// bool getBitValue(unsigned bitIdx) const;\n"
           "/// void setBitValue(unsigned bitIdx, bool value);\n"
           "/// \\endcode\n"
           "///\n"
           "/// Setting bit0 and bit7 may look like this:\n"
           "/// \\code\n"
           "/// " << fieldNs << "::someSet<> field; // All bits are initialised to false\n"
           "/// field.setBitValue(0, true);\n"
           "/// field.setBitValue(7, true);\n"
           "/// \\endcode\n"
           "/// \\b NOTE, that when default constructed the inner storage value is initialised\n"
           "/// to \\b 0, i.e. all the bits are cleared.\n"
           "/// The \\b COMMS library provides \\b COMMS_BITMASK_BITS() and \\b\n"
           "/// COMMS_BITMASK_BITS_ACCESS() macros to generate convenience enum and\n"
           "/// bit access functions. The \\b sbe2comms compiler adds usage of these\n"
           "/// macros to the generated class:\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someSet : public\n"
           "///     comms::field::BitmaskValue<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     // Provide names for internal bits.\n"
           "///     COMMS_BITMASK_BITS(\n"
           "///         bit0=0,\n"
           "///         bit1=1,\n"
           "///         bit5=5,\n"
           "///         bit7=7\n"
           "///     );\n"
           "///\n"
           "///     // Provide convenience access functions for internal bits.\n"
           "///     COMMS_BITMASK_BITS_ACCESS(\n"
           "///         bit0,\n"
           "///         bit1,\n"
           "///         bit5,\n"
           "///         bit7\n"
           "///     );\n"
           "///\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// The \\b COMMS_BITMASK_BITS() macro generates \\b BitIdx enum.\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someSet : public\n"
           "///     comms::field::BitmaskValue<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     enum BitIdx\n"
           "///     {\n"
           "///         BitIdx_bit0=0,\n"
           "///         BitIdx_bit1=1,\n"
           "///         BitIdx_bit5=5,\n"
           "///         BitIdx_bit7=7,\n"
           "///         BitIdx_numOfValues\n"
           "///     };\n"
           "///\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// And the \\b COMMS_BITMASK_BITS_ACCESS() macro generates convenience\n"
           "/// access functions for all the bits\n"
           "/// \\code\n"
           "/// template <typename... TOpt>\n"
           "/// class someSet : public\n"
           "///     comms::field::BitmaskValue<...>\n"
           "/// {\n"
           "///     using Base = ...;\n"
           "/// public:\n"
           "///\n"
           "///     bool getBitValue_bit0() const\n"
           "///     {\n"
           "///         return Base::getBitValue(BitIdx_bit0);\n"
           "///     }\n"
           "///\n"
           "///     void setBitValue_bit0(bool value)\n"
           "///     {\n"
           "///         Base::setBitValue(BitIdx_bit0, value);\n"
           "///     }\n"
           "///\n"
           "///     ... // And so on for all other bits\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// If the specified bits start from bit \\b 0 and go up without interruption,\n"
           "/// then \\b sbe2comms compiler chooses to use single \\b COMMS_BITMASK_BITS_SEQ()\n"
           "/// macro with the same effect.\n"
           "///\n"
           "/// \\subsection main_page_fields_composite \\<composite\\>\n"
           "/// The \\b composite fields are implemented by extending the \\b comms::field::Bundle\n"
           "/// class from the \\b COMMS library.\n"
           "///\n"
           "/// Let's define the following composite as an example:\n"
           "/// \\code\n"
           "/// <composite name=\"someComposite\">\n"
           "///     <type name=\"mem1\" primitiveType=\"uint8\" />\n"
           "///     <type name=\"mem2\" primitiveType=\"uint8\" />\n"
           "/// </composite>\n"
           "/// \\endcode\n"
           "/// Preceding the definition of the \\b composite field cass, there are\n"
           "/// its member fields, defined within a struct with the same name but with\n"
           "/// \\b *" << common::memembersSuffixStr() << " suffix.\n"
           "/// \\code\n"
           "/// //Scope for all the members of the \"someComposite\" field.\n"
           "/// struct someCompositeMembers\n"
           "/// {\n"
           "///     // Definition of \"mem1\" field.\n"
           "///     template <typename... TOpt>\n"
           "///     class mem1 : public comms::field::IntValue<...> { ... };\n"
           "///\n"
           "///     // Definition of \"mem2\" field.\n"
           "///     template <typename... TOpt>\n"
           "///     class mem2 : public comms::field::IntValue<...> { ... };\n"
           "///\n"
           "///     // Bundling all the defined member types into a single std::tuple.\n"
           "///     template<\n"
           "///         typename TOpt_mem1 = comms::option::EmptyOption,\n"
           "///         typename TOpt_mem2 = comms::option::EmptyOption\n"
           "///     >\n"
           "///     using All = std::tuple<\n"
           "///         mem1<TOpt_mem1>,\n"
           "///         mem2<TOpt_mem2>\n"
           "///     >;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Note the existence of \\b All type at the end. It bundles all the\n"
           "/// member fields into \\b std::tuple, which is used in the following\n"
           "/// definition of the \\b composite field itself\n"
           "/// \\code\n"
           "/// template<\n"
           "///     typename TOpt_mem1 = comms::option::EmptyOption,\n"
           "///     typename TOpt_mem2 = comms::option::EmptyOption\n"
           "/// >\n"
           "/// class someComposite : public\n"
           "///     comms::field::Bundle<\n"
           "///         FieldBase,\n"
           "///         someCompositeMembers::All<\n"
           "///             TOpt_mem1,\n"
           "///             TOpt_mem2\n"
           "///         >\n"
           "///     >\n"
           "/// {\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// A call to \\b value() member function of \\b comms::field::Bundle\n"
           "/// provides an access to the <b>tuple of member fields</b>\n"
           "/// \\code\n"
           "/// " << fieldNs << "::someComposite<> field;\n"
           "/// " << fieldNs << "::someCompositeMembers::All<>& memberFields = field.value();\n"
           "/// " << fieldNs << "::someCompositeMembers::mem1<>& mem1Field = std::get<0>(memberFields);\n"
           "/// " << fieldNs << "::someCompositeMembers::mem2<>& mem2Field = std::get<1>(memberFields);\n"
           "/// \\endcode\n"
           "/// The \\b COMMS library provides \\b COMMS_FIELD_MEMBERS_ACCESS() macro to\n"
           "/// generate convenience enum and members access functions. The \\b sbe2comms\n"
           "/// compiler adds usage of it to the generated class:\n"
           "/// \\code\n"
           "/// template<...>\n"
           "/// class someComposite : public comms::field::Bundle<...>\n"
           "/// {\n"
           "/// public:\n"
           "///     COMMS_FIELD_MEMBERS_ACCESS(mem1, mem2);\n"
           "///     ...\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// It is equivalent to having the following enum and access functions defined\n"
           "/// \\code\n"
           "/// template<...>\n"
           "/// class someComposite : public comms::field::Bundle<...>\n"
           "/// {\n"
           "///     using Base = ...;\n"
           "/// public:\n"
           "///     enum FieldIdx\n"
           "///     {\n"
           "///         FieldIdx_mem1,\n"
           "///         FieldIdx_mem2,\n"
           "///         FieldIdx_numOfValues\n"
           "///     };\n"
           "///\n"
           "///     // Access to first member\n"
           "///     decltype(auto) field_mem1()\n"
           "///     {\n"
           "///         return std::get<FieldIdx_mem1>(Base::value());\n"
           "///     }\n"
           "///\n"
           "///     // Const access to first member\n"
           "///     decltype(auto) field_mem1()  const\n"
           "///     {\n"
           "///         return std::get<FieldIdx_mem1>(Base::value());\n"
           "///     }\n"
           "///\n"
           "///     ... // Similar for mem2\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Please pay attention that the \b members are <b>field abstractions</b>\n"
           "/// themselves, which will require a call to their \\b value() member\n"
           "/// function to get an access to their stored values.\n"
           "/// \\code\n"
           "/// " << fieldNs << "::someComposite<> field;\n"
           "/// std::uint8_t mem1Value = field.field_mem1().value();\n"
           "/// std::uint8_t mem2Value = field.field_mem2().value();\n"
           "/// \\endcode\n"
           "/// According to SBE schema specification, the \\b composite field is\n"
           "/// considered to be \\b optional if its first member field is \\b optional and\n"
           "/// is considered to have \\b null value if its first member field has\n"
           "/// \\b null value. In such case the \\b sbe2comms compiler also generates\n"
           "/// \\b isNull() and \\b setNull() member functions that redirect the request\n"
           "/// to the first member field.\n"
           "///\n"
           "/// Sometimes a \\b composite type may describe a string or data list, when\n"
           "/// referenced by a \\b data field. If this is the case, the \\b composite\n"
           "/// field is implemented by extending \\b comms::field::String or\n"
           "/// \\b comms::field::ArrayList, similar to \\ref main_page_fields_type_string\n"
           "/// and \\ref main_page_fields_type_list, but without usage of\n"
           "/// \\b comms::option::SequenceFixedSize option.\n"
           "///\n"
           "/// \\subsection main_page_fields_ref \\<ref\\>\n"
           "/// Every \\b ref member of the \\b \\<composite\\> field\n"
           "/// is implemented as simple alias with \\b using C++ statement.\n"
           "///\n"
           "/// \\subsection main_page_fields_field \\<field\\>\n"
           "/// Usually the \\b \\<field\\> definition will be an alias to some field\n"
           "/// defined within \\b \\<types\\>. In this case the definition of the\n"
           "/// relevant field will be an alias to the field definition from the\n"
           "/// " << fieldNs << " namespace. However, using built-in types is also supported.\n"
           "/// \\code\n"
           "/// <field name=\"someField\" type=\"uint8\" />\n"
           "/// \\endcode\n"
           "/// In this case the alias will be to appropriate type from the\n"
           "/// " << builtinNs << " namespace.\n"
           "///\n"
           "/// Sometimes a \\b \\<field\\> extends a functionality defined by the referenced\n"
           "/// type. For example, becomes optional when the referenced \\b \\<type\\> is\n"
           "/// not. In this case the field class will be implemented by inheritance and\n"
           "/// required \\b isNull() and \\b setNull() functions will be added.\n"
           "///\n"
           "/// \\subsection main_page_fields_group \\<group\\>\n"
           "/// Let's take as an example the following \\b group definition\n"
           "/// \\code\n"
           "/// <group name=\"someGroup\" id=\"11\">\n"
           "///     <field name=\"someField\" id=\"12\" type=\"uint8\"/>\n"
           "///     <data name=\"someData\" id=\"13\" type=\"varStringEncoding\"/>\n"
           "/// </group>\n"
           "/// \\endcode\n"
           "/// It is defined in multiple stages. First, all the field members are defined\n"
           "/// in a struct having the same name as \\b group field, but with\n"
           "/// \\b *" << common::memembersSuffixStr() << " suffix.\n"
           "/// \\code\n"
           "/// // Scope for all the members of the \"someGroup\" field.\n"
           "/// struct someGroupMembers\n"
           "/// {\n"
           "///     // Definition of \"someField\" member field.\n"
           "///     using someField = sbe2comms::uint8<...>;\n"
           "///\n"
           "///     // Definition of \"someData\" member field.\n"
           "///     using someData = field::varStringEncoding<...>;\n"
           "///\n"
           "///     // Bundling all the defined member fields into a single std::tuple.\n"
           "///     using All = std::tuple<\n"
           "///         someField,\n"
           "///         someData\n"
           "///     >;\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// Then a list element is defined as \\b comms::field::Bundle, similar to\n"
           "/// definition of \\b composite field\n"
           "/// \\code\n"
           "/// // Element of someGroup list.\n"
           "/// class someGroupElement : public\n"
           "///     comms::field::Bundle<\n"
           "///         field::FieldBase,\n"
           "///         typename someGroupMembers::All\n"
           "///     >\n"
           "/// {\n"
           "/// public:\n"
           "///     // Allow access to internal fields.\n"
           "///     COMMS_FIELD_MEMBERS_ACCESS(someField, someData);\n"
           "/// };\n"
           "/// \\endcode\n"
           "/// And finaly definition of the group list field itself. It is defined\n"
           "/// as alias to sbe2comms::groupList common definition. The latter implements the\n"
           "/// group list field by extending \\b comms::field::ArrayList and overriding\n"
           "/// some member functions. Accessing the fields in the group list may look\n"
           "/// like this:\n"
           "/// \\code\n"
           "/// void handleGroupList(someGroup& field)\n"
           "/// {\n"
           "///     auto& vectorOfElements = field.value(); // access the storage vector\n"
           "///     auto& firstElement = vectorOfElements[0]; // ref to someGroupElement\n"
           "///     auto& firstElemSomeField = firstElement.field_someField(); // ref to the member field\n"
           "///     auto& firstElemSomeData = firstElement.field_someData(); // ref to the member field\n"
           "///     std::uint8_t someFieldValue = firstElemSomeField.value(); // access the member field value\n"
           "///     std::string& someDataValue = firstElemSomeData.value(); // access the member field value\n"
           "/// \\endcode\n"
           "/// By default the group list elements are stored in \\b std::vector. It can be\n"
           "/// changed using options from \\b comms::option namespace. Please refer\n"
           "/// to \\ref main_page_customization section below for details.\n"
           "///\n"
           "/// \\subsection main_page_fields_data \\<data\\>\n"
           "/// The \\b data fields are implemented as an alias to previously defined\n"
           "/// \\b composite, which is implemented by extending either\n"
           "/// \\b comms::field::String (for string fields) or\n"
           "/// \\b comms::field::ArrayList (for raw data lists).\n"
           "///\n"
           "/// \\section main_page_pad Padding\n"
           "///\n"
           "/// \\section main_page_transport Transport Frame\n"
           "/// TODO\n"
           "/// \\section main_page_customization Customization\n"
           "/// TODO\n"
           "/// \\section main_page_reserved_names Reserved Names\n"
           "/// TODO\n"
           "///\n\n";
    return true;
}




} // namespace sbe2comms
